package xinput

// This file listens on XEvents for devices. It's content is heavily inspired by xinput's test.c.

/*
#cgo LDFLAGS: -lX11 -lXi

#include <X11/Xlib.h>
#include <X11/extensions/XInput.h>

// XEventType returns a XEvent's type field. The type keyword is reserved in Go.
XEventClass XEventType(XEvent *event) {
	return event->type;
}
*/
import "C"
import (
	"fmt"
	"unsafe"
)

// EventMap listens on key, button, or motion events for a device.
type EventMap struct {
	display *C.Display

	keyPress      C.XEventClass
	keyRelease    C.XEventClass
	buttonPress   C.XEventClass
	buttonRelease C.XEventClass
	motion        C.XEventClass

	eventChan chan Event

	stopSyn chan struct{}
	stopAck chan struct{}
}

// EventType describes a Event's type.
type EventType string

const (
	KeyPressEvent      EventType = "key press"
	KeyReleaseEvent    EventType = "key release"
	ButtonPressEvent   EventType = "button press"
	ButtonReleaseEvent EventType = "button release"
	MotionEvent        EventType = "motion"
)

// Event describes a key, button, or motion event, generated by an EventMap.
type Event struct {
	Type  EventType
	Field uint
	Axes  map[int]int
}

// NewEventMap creates an event map to registers notifications for some device's events.
//
// This function was written analog to xinput's register_events function.
func NewEventMap(display *C.Display, xDeviceInfo XDeviceInfo) (eventMap *EventMap, err error) {
	eventMap = &EventMap{
		display:   display,
		eventChan: make(chan Event, 128),
		stopSyn:   make(chan struct{}),
		stopAck:   make(chan struct{}),
	}

	device := C.XOpenDevice(eventMap.display, C.ulong(xDeviceInfo.Id))

	if device == nil {
		err = fmt.Errorf("Unable to open device")
		return
	}

	var eventList []C.XEventClass

	cDeviceClasses := (*[1 << 15]C.XInputClassInfo)(unsafe.Pointer(device.classes))[:device.num_classes:device.num_classes]
	for _, cDeviceClass := range cDeviceClasses {
		// The original register_events function uses macros at this point, e.g., DeviceKeyPress.
		// Since this is not possible in Go / cgo, I reversed the macros and came to conclusion that
		// finally only the following variables are getting written. Everything else is a lookup we
		// already done ourself.
		//
		//   offset is 0 for press and 1 for release
		//   type = cDeviceClass.event_type_base + offset
		//   class = device.device_id << 8 | type

		switch cDeviceClass.input_class {
		case C.KeyClass:
			eventMap.keyPress = C.XEventClass(cDeviceClass.event_type_base + 0)
			eventList = append(eventList, device.device_id<<8|eventMap.keyPress)

			eventMap.keyRelease = C.XEventClass(cDeviceClass.event_type_base + 1)
			eventList = append(eventList, device.device_id<<8|eventMap.keyRelease)

		case C.ButtonClass:
			eventMap.buttonPress = C.XEventClass(cDeviceClass.event_type_base + 0)
			eventList = append(eventList, device.device_id<<8|eventMap.buttonPress)

			eventMap.buttonRelease = C.XEventClass(cDeviceClass.event_type_base + 1)
			eventList = append(eventList, device.device_id<<8|eventMap.buttonRelease)

		case C.ValuatorClass:
			eventMap.motion = C.XEventClass(cDeviceClass.event_type_base + 0)
			eventList = append(eventList, device.device_id<<8|eventMap.motion)
		}
	}

	screen := C.XDefaultScreen(eventMap.display)
	rootWin := C.XRootWindow(eventMap.display, screen)

	if C.XSelectExtensionEvent(eventMap.display, rootWin, &eventList[0], C.int(len(eventList))) != C.int(0) {
		err = fmt.Errorf("error selecting extended events")
		return
	}

	go eventMap.eventWorker()

	return
}

// parseKeyEvent creates a KeyEvent based on a XEvent.
func parseKeyEvent(xEvent *C.XEvent, eventType EventType) Event {
	key := (*C.XDeviceKeyEvent)(unsafe.Pointer(xEvent))

	axes := make(map[int]int)
	for loop := 0; loop < int(key.axes_count); loop++ {
		axes[int(key.first_axis)+loop] = int(key.axis_data[loop])
	}

	return Event{
		Type:  eventType,
		Field: uint(key.keycode),
		Axes:  axes,
	}
}

// parseButtonEvent creates a ButtonEvent based on a XEvent.
func parseButtonEvent(xEvent *C.XEvent, eventType EventType) Event {
	button := (*C.XDeviceButtonEvent)(unsafe.Pointer(xEvent))

	axes := make(map[int]int)
	for loop := 0; loop < int(button.axes_count); loop++ {
		axes[int(button.first_axis)+loop] = int(button.axis_data[loop])
	}

	return Event{
		Type:  eventType,
		Field: uint(button.button),
		Axes:  axes,
	}
}

// parseMotionEvent creates a MotionEvent based on a XEvent.
func parseMotionEvent(xEvent *C.XEvent) Event {
	motion := (*C.XDeviceMotionEvent)(unsafe.Pointer(xEvent))

	axes := make(map[int]int)
	for loop := 0; loop < int(motion.axes_count); loop++ {
		axes[int(motion.first_axis)+loop] = int(motion.axis_data[loop])
	}

	return Event{
		Type: MotionEvent,
		Axes: axes,
	}
}

// eventWorker is the background worker to listen for Events.
func (eventMap *EventMap) eventWorker() {
	defer close(eventMap.stopAck)

	for {
		select {
		case <-eventMap.stopSyn:
			return

		default:
			var xEvent C.XEvent
			var event Event

			C.XNextEvent(eventMap.display, &xEvent)

			switch C.XEventType(&xEvent) {
			case eventMap.keyPress:
				event = parseKeyEvent(&xEvent, KeyPressEvent)

			case eventMap.keyRelease:
				event = parseKeyEvent(&xEvent, KeyReleaseEvent)

			case eventMap.buttonPress:
				event = parseButtonEvent(&xEvent, ButtonPressEvent)

			case eventMap.buttonRelease:
				event = parseButtonEvent(&xEvent, ButtonReleaseEvent)

			case eventMap.motion:
				event = parseMotionEvent(&xEvent)
			}

			eventMap.eventChan <- event
		}
	}
}

// Events returns a channel of Events.
func (eventMap *EventMap) Events() chan Event {
	return eventMap.eventChan
}

// Close this EventMap and the Events channel.
func (eventMap *EventMap) Close() error {
	close(eventMap.stopSyn)
	<-eventMap.stopAck

	return nil
}
